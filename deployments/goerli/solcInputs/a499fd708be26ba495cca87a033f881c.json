{
  "language": "Solidity",
  "sources": {
    "contracts/MultiSig.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nerror MultiSig__InvalidAddress();\nerror MultiSig__DuplicateAddress(address duplicateAddr);\nerror MultiSig__OnlyOwner();\nerror MultiSig__InsufficientAmount();\nerror MultiSig__AlreadyConfirmed(uint256 txId);\nerror MultiSig__InvalidTransactionId(uint256 txId);\nerror MultiSig__TransactionAlreadyExecuted(uint256 txId);\nerror MultiSig__TxNotConfirmed(uint txId);\nerror MultiSig__NeedsMoreConfirmations(uint confirmations, uint confirmationsNeeded);\nerror MultiSig__TransactionExecutionFailed(uint txId);\nerror MultiSig__NeedMoreSharedFunds(uint sharedFunds, uint txValue);\nerror MultiSig__InsufficientBalance(uint userBalance, uint value);\nerror MultiSig__WithdrawFailed();\n\ncontract MultiSig {\n    // Type declarations\n\n    event OwnerAdded(address indexed owner);\n    event DepositSubmitted(\n        address indexed depositor,\n        uint256 indexed depositId,\n        uint256 indexed value\n    );\n    event TransactionProposed(\n        address indexed proposer,\n        address to,\n        uint256 indexed transactionId,\n        uint256 indexed value\n    );\n\n    struct Transaction {\n        address proposer;\n        address to;\n        bool executed;\n        bytes data;\n        uint256 transactionId;\n        uint256 value;\n        uint256 confirmations;\n    }\n    // I'm confused about these two lines of logic but I know they are used a lot\n    //Transaction public transaction;     <---\n\n    struct Deposit {\n        address depositor;\n        uint256 depositId;\n        uint256 value;\n    }\n    //Deposit public deposit;      <----\n\n    // State Variables\n    address[] public owners;\n    uint256 public s_confirmationsRequired;\n    uint256 public s_transactionCounter;\n    uint256 public s_depositCounter;\n    uint256 public s_sharedFunds;\n    Transaction[] public transactionArray;\n    Deposit[] public depositArray;\n    Deposit[] public nonOwnerDepositArray;\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(uint => bool)) public hasConfirmed;\n    mapping(address => bool) public isOwner;\n    mapping(address => Transaction[]) public addressToTxArray;\n    mapping(address => Deposit[]) public addressToDepositArray;\n\n    modifier onlyOwner() {\n        if (isOwner[msg.sender] == false) {\n            revert MultiSig__OnlyOwner();\n        }\n        _;\n    }\n\n    modifier exists(uint _txId) {\n        if (_txId >= transactionArray.length) {\n            revert MultiSig__InvalidTransactionId(_txId);\n        }\n        _;\n    }\n\n    modifier isExecuted(uint _txId) {\n        if (transactionArray[_txId].executed == true) {\n            revert MultiSig__TransactionAlreadyExecuted(_txId);\n        }\n        _;\n    }\n\n    /*\n     * Function ordering:\n     * constructor\n     * receive function (if exists)\n     * fallback function (if exists)\n     * external\n     * public\n     * internal\n     * private\n     */\n\n    constructor(address[] memory _owners, uint256 _confirmationsRequired) {\n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            if (owner == address(0)) {\n                revert MultiSig__InvalidAddress();\n            } else {\n                if (!isOwner[owner]) {\n                    owners.push(owner);\n                    isOwner[owner] = true;\n                    emit OwnerAdded(owner);\n                } else {\n                    revert MultiSig__DuplicateAddress(owner);\n                }\n            }\n        }\n        s_confirmationsRequired = _confirmationsRequired;\n        s_transactionCounter = 0;\n        s_depositCounter = 0;\n    }\n\n    receive() external payable {\n        submitDeposit();\n    }\n\n    function submitDeposit() public payable {\n        if (msg.value <= 0) {\n            revert MultiSig__InsufficientAmount();\n        }\n        Deposit memory newDeposit = Deposit(\n            msg.sender,\n            s_depositCounter,\n            msg.value\n        );\n        depositArray.push(newDeposit);\n\n        if (isOwner[msg.sender] == true) {\n            balances[msg.sender] += msg.value;\n            addressToDepositArray[msg.sender].push(newDeposit);\n        } else {\n            nonOwnerDepositArray.push(newDeposit);\n            s_sharedFunds += msg.value;\n        }\n        emit DepositSubmitted(msg.sender, s_depositCounter, msg.value);\n        s_depositCounter++;\n    }\n\n    function addSharedFunds(uint value) public onlyOwner {\n        if(balances[msg.sender] < value) {\n            revert MultiSig__InsufficientBalance(balances[msg.sender], value);\n        }\n        balances[msg.sender] -= value;\n        s_sharedFunds += value;     \n    }\n\n    function proposeTransaction(\n        address payable _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public onlyOwner {\n        Transaction memory newTransaction = Transaction(\n            msg.sender,\n            _to,\n            false,\n            _data,\n            s_transactionCounter,\n            _amount,\n            0\n        );\n        transactionArray.push(newTransaction);\n        addressToTxArray[msg.sender].push(newTransaction);\n        emit TransactionProposed(\n            msg.sender,\n            _to,\n            s_transactionCounter,\n            _amount\n        );\n        s_transactionCounter++;\n    }\n\n    function confirmTransaction(uint256 _txId)\n        public\n        onlyOwner\n        exists(_txId)\n        isExecuted(_txId)    \n    {\n        if (hasConfirmed[msg.sender][_txId] == true) {\n            revert MultiSig__AlreadyConfirmed(_txId);\n        }\n        hasConfirmed[msg.sender][_txId] = true;\n        transactionArray[_txId].confirmations += 1;\n    }\n\n    function revokeConfirmation(uint _txId) public onlyOwner exists(_txId) isExecuted(_txId) returns(uint) {\n        if(hasConfirmed[msg.sender][_txId] == false) {\n            revert MultiSig__TxNotConfirmed(_txId);\n        }\n        hasConfirmed[msg.sender][_txId] = false;\n        transactionArray[_txId].confirmations -= 1;\n    }\n\n    function executeTransaction(uint256 _txId) public onlyOwner exists(_txId) isExecuted(_txId){\n        if(transactionArray[_txId].confirmations < s_confirmationsRequired) {\n            revert MultiSig__NeedsMoreConfirmations(transactionArray[_txId].confirmations, s_confirmationsRequired);\n        }\n        Transaction storage transaction = transactionArray[_txId];\n        if(transaction.value > s_sharedFunds) {\n            revert MultiSig__NeedMoreSharedFunds(s_sharedFunds, transaction.value);\n        }\n        transaction.executed = true;\n        (bool sent, ) = transaction.to.call{value: transaction.value}(transaction.data);\n        if(!sent) {\n            revert MultiSig__TransactionExecutionFailed(_txId);\n        }\n        \n    }\n\n    function withdraw(uint amount) public onlyOwner {\n        if(balances[msg.sender] < amount) {\n            revert MultiSig__InsufficientBalance(balances[msg.sender], amount);\n        }\n        balances[msg.sender] -= amount;\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        if(!sent) {\n            revert MultiSig__WithdrawFailed();\n        }\n    }\n\n    function getBalance() public view returns(uint){\n        return address(this).balance;\n    }\n}\n"
    },
    "contracts/test/TestHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nerror TestHelper__SaysNoThanks();\n\nimport \"../MultiSig.sol\";\n\ncontract TestHelper {\n\n\n    receive() external payable {\n        revert TestHelper__SaysNoThanks();\n    }\n\n    // function sendValue(address payable _to, uint256 _amount) public returns(bool) {\n    //     (bool sent, ) = _to.call{value: _amount}(\"\");\n    //     require(sent, \"Failed to send!\");\n    //     return(sent);\n    // }\n\n    function withdraw(uint amount) public {\n        TestHelper.withdraw(amount);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}